name: Deploy Backend to VPS (fixed)

on:
  push:
    branches: ['main']

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy to Hostinger VPS
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install rsync and openssh-client
        run: sudo apt-get update -y && sudo apt-get install -y rsync openssh-client

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          # write private key from secret (normalize CRLFs)
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # add host key (best effort)
          if [ -n "${{ secrets.SSH_PORT }}" ]; then
            ssh-keyscan -p "${{ secrets.SSH_PORT }}" -H "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts || true
          else
            ssh-keyscan -H "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts || true
          fi

      - name: Runner SSH verbose debug (non-failing)
        run: |
          echo "=== Runner SSH verbose debug start ==="
          ssh -vvv -o BatchMode=yes -o IdentitiesOnly=yes -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'echo RUNNER_SSH_OK' || true
          echo "=== Runner SSH verbose debug end ==="

      - name: Quick SSH connectivity test
        run: |
          ssh -o BatchMode=yes -o IdentitiesOnly=yes -i ~/.ssh/id_rsa -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'echo SSH_OK' || true

      - name: Print runner private-key fingerprint (debug)
        run: |
          echo "Runner: fingerprint of ~/.ssh/id_rsa (public form)"
          ssh-keygen -y -f ~/.ssh/id_rsa 2>/dev/null | ssh-keygen -lf - || echo "Unable to read ~/.ssh/id_rsa or not a valid key"

      - name: Rsync project to server
        run: |
          RSYNC_RSH="ssh -p ${{ secrets.SSH_PORT }} -o IdentitiesOnly=yes -i ~/.ssh/id_rsa"
          rsync -az --exclude='.git' --exclude='node_modules' --exclude='.env' --exclude='.github' -e "$RSYNC_RSH" ./ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:${{ secrets.REMOTE_DIR }}

      - name: Remote install & restart
        run: |
          # Use a heredoc piped to 'bash -s' on the remote host to avoid complex escaping
          ssh -p ${{ secrets.SSH_PORT }} -o IdentitiesOnly=yes -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} bash -s <<'REMOTE_SCRIPT'
          REMOTE_DIR='${{ secrets.REMOTE_DIR }}'
          PM2_APP_NAME='${{ secrets.PM2_APP_NAME }}'
          set -euo pipefail

          echo "== remote: deploy start =="
          cd "$REMOTE_DIR"

          if [ -f package-lock.json ]; then
            npm ci --omit=dev
          else
            npm install --omit=dev
          fi

          if pm2 describe "$PM2_APP_NAME" > /dev/null 2>&1; then
            pm2 restart "$PM2_APP_NAME" --update-env
          else
            pm2 start index.js --name "$PM2_APP_NAME" --update-env
          fi

          pm2 save

          # healthcheck: retry several times (2s interval) and accept any 2xx/3xx status
          ok=1
          for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
            # save body to temp file and capture numeric HTTP status (000 if curl itself fails)
            STATUS=$(curl -sS -w "%{http_code}" -o /tmp/healthbody http://127.0.0.1:3001/ 2>/tmp/healthcurlerr || echo "000")
            # accept 2xx and 3xx
            case "$STATUS" in
              2*|3*) ok=0 ; break ;;
              *) echo "healthcheck attempt $i returned HTTP $STATUS" ;;
            esac
            sleep 2
          done

          if [ "$ok" -ne 0 ]; then
            echo 'Healthcheck failed — response body (if any):'
            if [ -f /tmp/healthbody ]; then
              echo '--- begin response body ---'
              cat /tmp/healthbody || true
              echo '--- end response body ---'
            else
              echo '/tmp/healthbody not found'
            fi
            if [ -s /tmp/healthcurlerr ]; then
              echo 'curl stderr:'
              cat /tmp/healthcurlerr || true
            fi
            echo 'Healthcheck failed — printing PM2 logs (last 200 lines):'
            echo 'Healthcheck failed — printing PM2 logs (last 200 lines):'
            # Tail the pm2-managed log files directly (non-streaming) to avoid keeping the SSH session open
            OUT_LOG="/root/.pm2/logs/${PM2_APP_NAME}-out.log"
            ERR_LOG="/root/.pm2/logs/${PM2_APP_NAME}-error.log"

            echo "-- Last lines of stdout log ($OUT_LOG):"
            if [ -f "$OUT_LOG" ]; then
              tail -n 200 "$OUT_LOG" || true
            else
              echo "$OUT_LOG not found"
            fi

            echo "-- Last lines of stderr log ($ERR_LOG):"
            if [ -f "$ERR_LOG" ]; then
              tail -n 200 "$ERR_LOG" || true
            else
              echo "$ERR_LOG not found"
            fi

            echo 'Also listing /root/.pm2/logs:'
            ls -l /root/.pm2/logs || true
            exit 2
          fi

          echo 'Healthcheck OK'
          echo "== remote: deploy end =="
          REMOTE_SCRIPT
